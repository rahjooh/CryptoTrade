name: CloudWatch Dashboard

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: "Enter the production dispatch passphrase"
        required: true
        default: ""

concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}-cloudwatch-dashboard
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  update-dashboard:
    name: Update CloudWatch dashboard
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ vars.AWS_REGION != '' && vars.AWS_REGION || 'ap-south-1' }}
    steps:
      - name: Determine dashboard name
        shell: bash
        run: |
          set -euo pipefail
          default_name="${{ vars.DASHBOARD_NAME != '' && vars.DASHBOARD_NAME || 'Data' }}"
          name="$default_name"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            input_name="$(jq -r '.inputs.dashboard_name // ""' "$GITHUB_EVENT_PATH")"
            if [ -n "$input_name" ]; then
              name="$input_name"
            fi
          fi
          echo "DASHBOARD_NAME=$name" >> "$GITHUB_ENV"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Load instance resolution hints
        env:
          ENV_SECRET: ${{ secrets.ENV }}
          VAR_PROD_INSTANCE_ID: ${{ vars.PROD_INSTANCE_ID }}
          VAR_PROD_INSTANCE_NAME: ${{ vars.PROD_INSTANCE_NAME }}
          VAR_STAGE_INSTANCE_ID: ${{ vars.STAGE_INSTANCE_ID }}
          VAR_STAGE_INSTANCE_NAME: ${{ vars.STAGE_INSTANCE_NAME }}
        run: |
          set -Eeuo pipefail
          
          write_hint() {
            local key="$1" value="$2"
            if [ -n "$value" ] && [ "$value" != "null" ]; then
              printf '%s=%s\n' "$key" "$value" >> "$GITHUB_ENV"
              printf '::add-mask::%s\n' "$value"
            fi
          }
          
          write_hint PROD_INSTANCE_ID "${VAR_PROD_INSTANCE_ID:-}"
          write_hint PROD_INSTANCE_NAME "${VAR_PROD_INSTANCE_NAME:-}"
          write_hint STAGE_INSTANCE_ID "${VAR_STAGE_INSTANCE_ID:-}"
          write_hint STAGE_INSTANCE_NAME "${VAR_STAGE_INSTANCE_NAME:-}"
          
          if [ -n "${ENV_SECRET:-}" ]; then
            printf '%s\n' "$ENV_SECRET" \
              | tr -d '\r' \
              | sed -E '/^[[:space:]]*#/d; /^[[:space:]]*$/d' \
              | sed -n -E 's/^[[:space:]]*(PROD_INSTANCE_ID|STAGE_INSTANCE_ID|PROD_INSTANCE_NAME|STAGE_INSTANCE_NAME)[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$/\1=\2/p' \
              | while IFS='=' read -r key value; do
                  write_hint "$key" "$value"
                done
          fi

      - name: Resolve prod/stage instances and host info
        id: ec2
        run: |
          set -euo pipefail
          : "${PROD_INSTANCE_NAME:=Gollector_prod}"
          : "${STAGE_INSTANCE_NAME:=Gollector_stage}"
          
          diag_list() {
            echo "::group::EC2 instance diagnostic ($AWS_REGION)"
            aws ec2 describe-instances \
              --filters "Name=instance-state-name,Values=running,stopped,pending,stopping" \
              --query 'Reservations[].Instances[].{Id:InstanceId,State:State.Name,Name:Tags[?Key==`Name`]|[0].Value,AZ:Placement.AvailabilityZone}' \
              --output table || true
            echo "::endgroup::"
          }
          
          # Use first match helper
          first_or_empty() {
            awk 'NF{print $1; exit}'
          }
          
          resolve_by_name_exact() {
            local name="$1"
            aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=${name}" "Name=instance-state-name,Values=running,stopped,pending,stopping" \
              --query "Reservations[].Instances[].InstanceId" --output text | first_or_empty
          }
          
          resolve_by_name_wild() {
            local name="$1"
            # allow minor mismatches like trailing spaces or different case: try wildcard
            aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=*${name}*" "Name=instance-state-name,Values=running,stopped,pending,stopping" \
              --query "Reservations[].Instances[].InstanceId" --output text | first_or_empty
          }
          
          resolve_instance() {
            local id="${1:-}" name="${2:-}"
            if [ -n "${id:-}" ] && [ "${id:-}" != "null" ]; then
              echo "$id"; return 0
            fi
            local iid
            iid="$(resolve_by_name_exact "$name")"
            if [ -z "$iid" ] || [ "$iid" = "None" ]; then
              iid="$(resolve_by_name_wild "$name")"
            fi
            echo "${iid:-}"
          }
          
          # show what's in the region to make debugging easy
          diag_list
          
          PROD_IID="$(resolve_instance "${PROD_INSTANCE_ID:-}" "${PROD_INSTANCE_NAME:-}")"
          STAGE_IID="$(resolve_instance "${STAGE_INSTANCE_ID:-}" "${STAGE_INSTANCE_NAME:-}")"
          
          if [ -z "$PROD_IID" ] || [ "$PROD_IID" = "None" ]; then
            echo "ERROR: Could not find PROD. Checked:"
            echo " - Region: $AWS_REGION"
            echo " - PROD_INSTANCE_ID: ${PROD_INSTANCE_ID:-<unset>}"
            echo " - PROD_INSTANCE_NAME: ${PROD_INSTANCE_NAME:-<unset>} (exact + wildcard)"
            exit 1
          fi
          if [ -z "$STAGE_IID" ] || [ "$STAGE_IID" = "None" ]; then
            echo "ERROR: Could not find STAGE. Checked:"
            echo " - Region: $AWS_REGION"
            echo " - STAGE_INSTANCE_ID: ${STAGE_INSTANCE_ID:-<unset>}"
            echo " - STAGE_INSTANCE_NAME: ${STAGE_INSTANCE_NAME:-<unset>} (exact + wildcard)"
            exit 1
          fi
          
          read -r PROD_PRIVATE_IP PROD_PRIVATE_DNS <<<"$(aws ec2 describe-instances --instance-ids "$PROD_IID" --query 'Reservations[0].Instances[0].[PrivateIpAddress,PrivateDnsName]' --output text)"
          read -r STAGE_PRIVATE_IP STAGE_PRIVATE_DNS <<<"$(aws ec2 describe-instances --instance-ids "$STAGE_IID" --query 'Reservations[0].Instances[0].[PrivateIpAddress,PrivateDnsName]' --output text)"
          
          PROD_HOST_SHORT="${PROD_PRIVATE_DNS%%.*}"
          STAGE_HOST_SHORT="${STAGE_PRIVATE_DNS%%.*}"
          
          {
            echo "prod_instance_id=$PROD_IID"
            echo "stage_instance_id=$STAGE_IID"
            echo "prod_ip=$PROD_PRIVATE_IP"
            echo "stage_ip=$STAGE_PRIVATE_IP"
            echo "prod_host=$PROD_HOST_SHORT"
            echo "stage_host=$STAGE_HOST_SHORT"
          } >> "$GITHUB_OUTPUT"

      - name: Build dual-env dashboard body
        run: |
          set -euo pipefail
          cp internal/metrics/CWdash.json /tmp/dashboard.json
          sed -i \
            -e "s|<prod-instance-id>|${{ steps.ec2.outputs.prod_instance_id }}|g" \
            -e "s|<stage-instance-id>|${{ steps.ec2.outputs.stage_instance_id }}|g" \
            -e "s|<prod-ip>|${{ steps.ec2.outputs.prod_ip }}|g" \
            -e "s|<stage-ip>|${{ steps.ec2.outputs.stage_ip }}|g" \
            -e "s|<prod-hostname>|${{ steps.ec2.outputs.prod_host }}|g" \
            -e "s|<stage-hostname>|${{ steps.ec2.outputs.stage_host }}|g" \
            /tmp/dashboard.json

      - name: Put dashboard
        run: |
          aws cloudwatch put-dashboard \
            --dashboard-name "$DASHBOARD_NAME" \
            --dashboard-body file:///tmp/dashboard.json

      - name: Validate dashboard
        run: |
          aws cloudwatch get-dashboard --dashboard-name "$DASHBOARD_NAME" \
            --query 'DashboardValidationMessages' --output table