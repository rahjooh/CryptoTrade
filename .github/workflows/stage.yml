name: Stage

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: "Type 'deploy' to ship the staging release"
        required: true
        default: deploy

concurrency:
  group: deploy-staging
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  test-ssh:
    name: Verify staging SSH connectivity
    if: github.ref == 'refs/heads/main' && github.event.inputs.confirm == 'deploy'
    runs-on: ubuntu-latest
    steps:
      - name: Load ENV secret into $GITHUB_ENV
        shell: bash
        env:
          ENV_SECRET: ${{ secrets.ENV }}
        run: |
          set -Eeuo pipefail
          
          # 1) Write all plain KEY=VALUE lines (no comments) for next steps
          printf '%s\n' "$ENV_SECRET" \
            | tr -d '\r' \
            | sed -E '/^[[:space:]]*#/d; /^[[:space:]]*$/d' >> "$GITHUB_ENV"

          # Mask each value present in the ENV secret to avoid log leaks
          printf '%s\n' "$ENV_SECRET" \
            | tr -d '\r' \
            | sed -E '/^[[:space:]]*#/d; /^[[:space:]]*$/d; s/^[^=]+=//' \
            | while IFS= read -r __val; do
                if [ -n "$__val" ]; then echo "::add-mask::$__val"; fi
              done
          
          # 2) Defaults (safe with set -u)
          : "${EC2_USER:=}"
          : "${DASHBOARD_NAME:=Data}"
          : "${LOG_LEVEL:=warn}"
          if [ -z "${APP_DIR:-}" ] && [ -n "${EC2_USER}" ]; then
            echo "APP_DIR=/home/${EC2_USER}/cryptoflow" >> "$GITHUB_ENV"
          fi
          echo "DASHBOARD_NAME=$DASHBOARD_NAME" >> "$GITHUB_ENV"
          echo "LOG_LEVEL=$LOG_LEVEL" >> "$GITHUB_ENV"
          
          # 3) Decode EC2_SSH_KEY_B64 from the secret into a multiline EC2_SSH_KEY
          key_b64="$(printf '%s\n' "$ENV_SECRET" \
            | tr -d '\r' \
            | sed -n -E 's/^[[:space:]]*EC2_SSH_KEY_B64[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$/\1/p')"
          if [ -n "$key_b64" ]; then
            {
              echo 'EC2_SSH_KEY<<EOF'
              printf '%s' "$key_b64" | base64 -d
              echo
              echo 'EOF'
            } >> "$GITHUB_ENV"
            # Mask the base64 and each decoded line
            echo "::add-mask::$key_b64"
            printf '%s' "$key_b64" | base64 -d | sed 's/.*/::add-mask::&/'
          fi

      - name: Verify loaded env keys
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "Loaded keys (showing only whether set):"
          for k in AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_REGION S3_BUCKET DASHBOARD_NAME LOG_LEVEL EC2_HOST_STAGE; do
          if [ "${!k-}" != "" ]; then
           echo "  $k = (set)"
          else
           echo "  $k = (missing/empty)"
          fi
          done

      - name: Check SSH access to staging host
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.EC2_HOST_STAGE }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_SSH_KEY }}
          port: 22
          timeout: 30s
          command_timeout: 10m
          proxy_port: 22
          proxy_timeout: 30s
          script: |
            set -euo pipefail
            echo "Staging host reachable as $(whoami)"
  test:
    name: Run test suite
    if: github.ref == 'refs/heads/main' && github.event.inputs.confirm == 'deploy'
    runs-on: ubuntu-latest
    needs: test-ssh
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: false

      - name: Download dependencies
        run: go mod download

      - name: Execute tests
        run: go test ./...

  build:
    name: Build application binary
    if: github.ref == 'refs/heads/main' && github.event.inputs.confirm == 'deploy'
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: false

      - name: Download dependencies
        run: go mod download

      - name: Prune stale binary artifacts (quota guard)
        run: |
          rm -f cryptoflow

      - name: Build binary
        run: go build -o cryptoflow .

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: staging-binary
          path: cryptoflow

      - name: Clean workspace & caches (post)
        if: always()
        run: |
          go clean -cache -modcache
          rm -f cryptoflow

  deploy:
    name: Deploy to staging
    if: github.ref == 'refs/heads/main' && github.event.inputs.confirm == 'deploy'
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: staging
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ vars.AWS_REGION }}
      S3_BUCKET: ${{ vars.S3_BUCKET }}
      S3_TABLE_ARN: ${{ secrets.S3_TABLE_ARN }}
      LOG_LEVEL: ${{ vars.LOG_LEVEL }}
      DASHBOARD_NAME: Data
    steps:
      - name: Load ENV secret
        env:
          ENV_SECRET: ${{ secrets.ENV }}
        run: |
          set -euo pipefail
          printf '%s\n' "${ENV_SECRET}" | sed -e '/^\s*#/d' -e '/^\s*$/d' >> "$GITHUB_ENV"
          # Mask each value present in the ENV secret to avoid log leaks
          printf '%s\n' "$ENV_SECRET" \
            | tr -d '\r' \
            | sed -E '/^[[:space:]]*#/d; /^[[:space:]]*$/d; s/^[^=]+=//' \
            | while IFS= read -r __val; do
                if [ -n "$__val" ]; then echo "::add-mask::$__val"; fi
              done
          if [ -z "${APP_DIR:-}" ] && [ -n "${EC2_USER:-}" ]; then
            echo "APP_DIR=/home/${EC2_USER}/cryptoflow" >> "$GITHUB_ENV"
          fi
          if [ -z "${DASHBOARD_NAME:-}" ]; then echo "DASHBOARD_NAME=Data" >> "$GITHUB_ENV"; fi
          if [ -z "${LOG_LEVEL:-}" ]; then echo "LOG_LEVEL=warn" >> "$GITHUB_ENV"; fi

      - name: Decode SSH key from base64
        if: env.EC2_SSH_KEY_B64 != ''
        run: |
          set -euo pipefail
          printf 'EC2_SSH_KEY<<EOF\n%s\nEOF\n' "$(printf '%s' "$EC2_SSH_KEY_B64" | base64 -d)" >> "$GITHUB_ENV"
          # Mask the base64 and each decoded line
          echo "::add-mask::${EC2_SSH_KEY_B64}"
          printf '%s' "$EC2_SSH_KEY_B64" | base64 -d | sed 's/.*/::add-mask::&/'

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: staging-binary
          path: artifacts

      - name: Place binary in workspace
        run: mv artifacts/cryptoflow ./cryptoflow

      - name: Ensure remote workspace exists
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.EC2_HOST_STAGE }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_SSH_KEY }}
          envs: APP_DIR
          script: |
            set -euo pipefail
            mkdir -p "$APP_DIR"
            cd "$APP_DIR"
            find . -mindepth 1 -maxdepth 1 ! -name '.env' ! -name 'data' -exec rm -rf {} +

      - name: Upload application bundle
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.EC2_HOST_STAGE }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_SSH_KEY }}
          source: ".,cryptoflow"
          target: "${{ env.APP_DIR }}"

      - name: Restart services
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.EC2_HOST_STAGE }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_SSH_KEY }}
          envs: APP_DIR,AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,AWS_REGION,S3_BUCKET,LOG_LEVEL
          script: |
            set -euo pipefail
            cd "$APP_DIR/infra/docker"
            # Create an env file and export for docker compose
            install -m 600 /dev/null .env
            {
              printf 'AWS_ACCESS_KEY_ID=%s\n' "$AWS_ACCESS_KEY_ID"
              printf 'AWS_SECRET_ACCESS_KEY=%s\n' "$AWS_SECRET_ACCESS_KEY"
              printf 'AWS_REGION=%s\n' "${AWS_REGION}"
              printf 'S3_BUCKET=%s\n' "${S3_BUCKET}"
              printf 'LOG_LEVEL=%s\n' "${LOG_LEVEL:-warn}"
            } >> .env
            set -a; . ./.env; set +a
            export APP_ENV=staging
            if docker compose version >/dev/null 2>&1; then
              COMPOSE_BIN="docker compose"
            elif command -v docker-compose >/dev/null 2>&1; then
              COMPOSE_BIN="docker-compose"
            else
              echo "Docker Compose is not installed on the target host." >&2
              exit 1
            fi
            # Use a stable project name for predictable resources
            export COMPOSE_PROJECT_NAME=cryptoflow
            # If a leftover container named 'cryptoflow' exists (outside this compose project), remove it to avoid name conflicts
            if docker ps -a --format '{{.Names}}' | grep -Fxq cryptoflow; then
              echo "Removing existing container 'cryptoflow' to avoid name conflict..."
              docker rm -f cryptoflow || true
            fi
            # shellcheck disable=SC2086
            $COMPOSE_BIN down --remove-orphans || true
            # shellcheck disable=SC2086
            $COMPOSE_BIN up -d --build

      - name: Delete binary artifact (post-deploy cleanup)
        if: always()
        run: |
          rm -f cryptoflow
          rm -rf artifacts

      # --- Optional CloudWatch dashboard refresh (commit with [CWdash]) ---
      - name: Configure AWS creds
        if: contains(github.event.head_commit.message, '[CWdash]')
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve collector InstanceId
        if: contains(github.event.head_commit.message, '[CWdash]')
        id: ec2
        run: |
          IID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=Collector Test 2" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId" --output text)
          if [ -z "$IID" ]; then echo "No running collector instance found"; exit 1; fi
          echo "instance_id=$IID" >> "$GITHUB_OUTPUT"

      - name: Inject InstanceId into dashboard JSON
        if: contains(github.event.head_commit.message, '[CWdash]')
        run: |
          cp internal/metrics/CWdash.json /tmp/dashboard.json
          sed -i "s|<collector-instance-id>|${{ steps.ec2.outputs.instance_id }}|g" /tmp/dashboard.json

      - name: Put dashboard
        if: contains(github.event.head_commit.message, '[CWdash]')
        run: |
          aws cloudwatch put-dashboard \
            --dashboard-name "$DASHBOARD_NAME" \
            --dashboard-body file:///tmp/dashboard.json

      - name: Validate dashboard
        if: contains(github.event.head_commit.message, '[CWdash]')
        run: |
          aws cloudwatch get-dashboard --dashboard-name "$DASHBOARD_NAME" \
            --query 'DashboardValidationMessages' --output table
